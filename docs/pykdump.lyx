#LyX 1.5.1 created this file. For more info see http://www.lyx.org/
\lyxformat 276
\begin_document
\begin_header
\textclass docbook
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\paperfontsize default
\papersize default
\use_geometry false
\use_amsmath 0
\use_esint 0
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\end_header

\begin_body

\begin_layout Title
Pykdump - Tutorial And Reference
\end_layout

\begin_layout Date
Date 
\end_layout

\begin_layout Author
\begin_inset CharStyle Firstname
show_label true
status inlined

\begin_layout Standard
Alex
\end_layout

\end_inset


\begin_inset CharStyle Surname
show_label true
status inlined

\begin_layout Standard
Sidorenko
\end_layout

\end_inset


\end_layout

\begin_layout Author
asid@hp.com
\end_layout

\begin_layout Abstract
This is a brief tutorial explaining how to use Pykdump.
 The current version is 0.3 
\end_layout

\begin_layout Section
Tutorial
\end_layout

\begin_layout Standard
If you have never used Python before, please read an excellent tutorial
 at 
\begin_inset LatexCommand url
name "http://docs.python.org/tut/tut.html"
target "http://docs.python.org/tut/tut.html"

\end_inset

 
\end_layout

\begin_layout Standard
An absolute minimum you need to know about Python to understand all our
 examples: 
\end_layout

\begin_layout Itemize
code blocks in Python are marked by indentation only - no {} brackets! 
\end_layout

\begin_layout Itemize
printing expressions:
\end_layout

\begin_layout Code

\family typewriter
    print expr1, expr2, ..., exprn
\family default
 
\end_layout

\begin_layout Itemize
printing and formatting: somewhat similar to C-printf, but arguments are
 specified in a tuple after percent operator:
\end_layout

\begin_layout Code

\family typewriter
    print "%s %d" % (s1, i1) 
\end_layout

\begin_layout Itemize
if-statements are similar to C but you cannot use assignment in them, e.g.
 the following will not work:
\end_layout

\begin_layout Code

\family typewriter
    if (s1 = func()) 
\end_layout

\begin_layout Itemize
for-statements loop over a sequence (or an iterable).
 Examples: 
\end_layout

\begin_layout Code
      for s in ("s1", "s2", "s3"):
\end_layout

\begin_layout Code
          print s
\end_layout

\begin_layout Code
      for i in range(1, 10):
\end_layout

\begin_layout Code
          print i
\end_layout

\begin_layout Quotation

\family roman
Here 
\family typewriter
range(1,10)
\family roman
 expands to sequence of integers starting at 1 and ending at 9, similar
 to C
\end_layout

\begin_deeper
\begin_layout Code
 for (i=1; i < 10; i++)
\end_layout

\end_deeper
\begin_layout Itemize
functions and methods can have a variable number of arguments.
 Some of them can be defined as keyword arguments, e.g.
 
\end_layout

\begin_layout Code

\family typewriter
     func(1, 2, mykeyarg=3)
\end_layout

\begin_layout Itemize
comments are introduced using a hash # sign
\end_layout

\begin_layout Standard
Uniform Python API is used both for script-driven and loadable extension-based
 versions.
 A very basic example showing how to use API:
\end_layout

\begin_layout Code
#!/usr/bin/env python
\end_layout

\begin_layout Code
# This imports all the functions you can use from pykdump
\end_layout

\begin_layout Code
from pykdump.API import *
\end_layout

\begin_layout Code

\end_layout

\begin_layout Code
# Check whether symbol exists
\end_layout

\begin_layout Code
if (symbol_exists('all_bdevs')):
\end_layout

\begin_layout Code
    print "all_bdevs exists"
\end_layout

\begin_layout Code
# Read the contents of 'tcp_hashinfo' table.
 The result type is chosen 
\end_layout

\begin_layout Code
# automatically according to symbol definition
\end_layout

\begin_layout Code
tcp_hashinfo = readSymbol('tcp_hashinfo')
\end_layout

\begin_layout Code
# Print the size of ESTABLISHED hash-table
\end_layout

\begin_layout Code
print tcp_hashinfo.__tcp_ehash_size
\end_layout

\begin_layout Subsection
Mapping C-structures To Python Objects
\end_layout

\begin_layout Standard
The Linux kernel is written in C (plus a bit of assembly).
 To be able to write useful dump-analysis scripts easily, we need two things:
 
\end_layout

\begin_layout Itemize
to be able to read memory, global variables and struct/union contents 
\end_layout

\begin_layout Itemize
to be able to write Python code easily looking at related C-sources
\end_layout

\begin_layout Standard
For example, if we want to write a program printing routing tables from
 a dump, we start from looking at how this is implemented in /proc routines.
 It would be nice to be able to copy and paste pieces of related C-sources
 to our script, but this would be extremely tricky, even if we used an embedded
 C-intepreter instead of Python.
 
\end_layout

\begin_layout Standard
Python has most operators that C does, but there is no direct analog for
 operators '*', '->', and '&' as Python passes everything by reference,
 there are no pointers.
 It is easy to mimic reading and accessing fields of C struct/union in Python
 as both C and Python have the dot '.' operator:
\end_layout

\begin_layout Code
struct blk_major_name {
\end_layout

\begin_layout Code
   struct blk_major_name *next;
\end_layout

\begin_layout Code
   int major;
\end_layout

\begin_layout Code
   char name[16];
\end_layout

\begin_layout Code
} svar;
\end_layout

\begin_layout Code

\end_layout

\begin_layout Code
s = readSU('struct blk_major_name', addr)
\end_layout

\begin_layout Code
major = s.major 
\end_layout

\begin_layout Code
print "%3d       %-11s" % (major, s.name) 
\end_layout

\begin_layout Standard
Here we read 'struct blk_major_name' from a given address and print the
 'major' field.
 Python has many built-in data types, including integers, floating-point
 numbers and strings.
 We would like to return properly typed values automatically, without specifying
 type explicitly every time.
 There is no special pointer type in Python but we can represent pointers
 by integers.
 In the example above we expect to get:
\end_layout

\begin_layout Itemize
s.next as integer 
\end_layout

\begin_layout Itemize
s.major as integer 
\end_layout

\begin_layout Itemize
s.name as string 
\end_layout

\begin_layout Standard
There are some problems with this approach.
 If we meet 'char name[16]' declaration, how do we know whether it is intended
 to be used as a string or an array of 1-byte integers? We cannot know this
 from symbolic information available in vmcore.
 To workaround this, we introduce a special 'SmartString' type which mimics
 null-terminated strings but lets you access info just like a normal array.
 So if 'name' is a SmartString, printing it will result in truncation on
 NULL byte but we still can access any byte using array access:
\end_layout

\begin_layout Code
name="abc
\backslash
0
\backslash
5
\backslash
6
\backslash
7
\backslash
8
\backslash
9
\backslash
10
\backslash
11
\backslash
12
\backslash
13
\backslash
14
\backslash
15
\backslash
16"
\end_layout

\begin_layout Code
print s.name  # will print abc 
\end_layout

\begin_layout Code
print s.name[5] # will print 5
\end_layout

\begin_layout Standard
In most cases you can work with these 
\emph on
SmartStrings 
\emph default
just like with normal Python strings, but in some cases Python library functions
 check type explicitly (e.g.
 you cannot pass 
\emph on
SmartString
\emph default
 to regular expressions functions).
 For the example above case you can convert 
\emph on
SmartString
\emph default
 s.name to a normal string using 
\end_layout

\begin_layout Code
str(s.name)
\end_layout

\begin_layout Standard
By default, struct/union members that are defined as char pointers or char
 arrays, are returned as 'SmartString' type.
 If they have explicit 'signed' or 'unsigned' specifiers, they are returned
 as integer arrays.
\end_layout

\begin_layout Subsection
Dereferencing Pointers in Structs and Unions (Emulating * and -> Operators)
\end_layout

\begin_layout Standard
What if we want to follow the 'next' pointer in the example above? In C
 we can write
\end_layout

\begin_layout Code
svar->next;
\end_layout

\begin_layout Code
svar->next->next;
\end_layout

\begin_layout Standard
and it will take into account the pointer type automatically (as compiler
 has access to definitions).
 There is no dereference operator in Python but we still can dereference
 using one of the following approaches: 
\end_layout

\begin_layout Itemize
load the needed structure from the known address manually 
\end_layout

\begin_layout Itemize
use a special 'Deref' attribute which emulates dereference, e.g.
\end_layout

\begin_layout Code
next = readSU("'struct blk_major_name", s.next) # the 1st approach
\end_layout

\begin_layout Code
next = s.Deref.next                             # the 2nd approach
\end_layout

\begin_layout Standard
To emulate the missing features we can define some attributes as special
 (in Python you can bind an arbitrary action for attribute access).
 Obviously this would not work as expected if we had a struct field with
 'Deref' name.
 Luckily, this is highly improbable for kernel structures.
 The "Linux Coding Style" document, 
\begin_inset LatexCommand url
name "Coding_Style"
target "http://www.llnl.gov/linux/slurm/coding_style.pdf"

\end_inset

, says: "mixed-case names are frowned upon" so using 'Deref' should be safe
 enough.
 The "internal" methods of Python classes are all named like __aname__ and
 once again we have never seen Linux kernel structures with a pattern like
 that.
 
\end_layout

\begin_layout Subsection
Emulating & Operator
\end_layout

\begin_layout Standard
In some cases we need to find the address of struct/union member instead
 of accessing its value.
 For example, we have a field which is defined as a struct (not a pointer),
 e.g.
\end_layout

\begin_layout Code
type = struct task_struct {
\end_layout

\begin_layout Code
   volatile long int state;
\end_layout

\begin_layout Code
   ...
\end_layout

\begin_layout Code
   struct list_head tasks;
\end_layout

\begin_layout Code
}
\end_layout

\begin_layout Standard
When we access 'tasks' attribute, we obtain an object representing a structure.
 For such objects we can use Addr(obj) function to obtain the associated
 address, e.g.
 
\end_layout

\begin_layout Code
init_task = readSymbol('init_task')
\end_layout

\begin_layout Code
init_task_saddr = Addr(init_task.tasks) 
\end_layout

\begin_layout Standard
If we need to obtain address of a field of another type (e.g.
 int) we have to compute it manually using low-level functions, e.g.
 
\end_layout

\begin_layout Code
dev_base = readSymbol("dev_base")
\end_layout

\begin_layout Code
offset = member_offset("struct net_device", "next")
\end_layout

\begin_layout Code
addr_next = Addr(dev_base) + offset
\end_layout

\begin_layout Standard
In the future we might add a special attribute similar to 'Deref' doing
 the needed work for us - but this is not implemented yet.
\end_layout

\begin_layout Subsection
Some Special Types
\end_layout

\begin_layout Standard
We map all C integer types to Python native 'long integer' type and we map
 C struct/union instances to 'class StructResult' instances.
 Pointers and arrays are normally represented by Python integers and lists.
 But in some cases we would like to preserve additional information while
 returning value so that we use classes instead of Python integers strings.
 Please note that you usually do not construct objects of these type yourself,
 they will be initialized and returned as needed when using 
\series bold
\emph on
readSymbol
\series default
\emph default
 and similar functions.
 Three most important cases are 
\emph on
StructResult
\emph default
 (to represent C structs/unions), 
\emph on
tPtr 
\emph default
(to represent pointers to different C-types) and 
\emph on
SmartString
\emph default
 (used for C char * pointers).
 When you obtain these objects from 
\series bold
\emph on
readSymbol
\series default
\emph default
, they store internally additional useful information.
 
\end_layout

\begin_layout Subsubsection
StructResult
\end_layout

\begin_layout Standard
This type represents struct/union.
 Operations that we can use:
\end_layout

\begin_layout Code
s = readSU("struct sock", addr)     # read from address addr
\end_layout

\begin_layout Code
socket = s.socket                   # similar to C s.socket
\end_layout

\begin_layout Code
addr = Addr(s)                      # similar to C &s
\end_layout

\begin_layout Subsubsection
tPtr - A Typed Pointer
\end_layout

\begin_layout Standard
When a variable is a pointer, we treat it as an integer.
 But it would be nice to attach to it the type of the pointer, so that we
 can use this information for dereferencing and other purposes.
\end_layout

\begin_layout Standard

\series bold
\emph on
tPtr
\series default
\emph default
 class inherits from 'long' so it can be used as a normal 'long' integer.
 For example, it's OK to use it in arithmetical expressions.
 In some rare cases the library functions check for type of passed object
 explicitly.
 You can always convert 
\series bold
\emph on
tPtr 
\series default
\emph default
to a plain long by doing conversion explictly,
\end_layout

\begin_layout Code
t = tPtr(123, "struct task_struct")
\end_layout

\begin_layout Code
i = long(t)
\end_layout

\begin_layout Standard
We return this type when a global variable or struct member is defined as
 a pointer to struct.
 It contains internally both address and pointer type.
 You can dereference it using Deref function atribute.
 For example:
\end_layout

\begin_layout Code
s = readSU("struct sock", addr)
\end_layout

\begin_layout Code
#s.socket->inode->i_ino
\end_layout

\begin_layout Code
ino = s.socket.Deref.inode.Deref.i_ino
\end_layout

\begin_layout Standard
A few words about mapping between C-code as present in kernel and Python
 code.
 In C, we use pointers extensively.
 While rewriting the same algorithm in Python, we can use both struct/unions
 object (class StructResult) and pointers to them.
 For example:
\end_layout

\begin_layout Code
/* in C */
\end_layout

\begin_layout Code
struct AAA *a;
\end_layout

\begin_layout Code
int b = a->field1;
\end_layout

\begin_layout Code
# In Python:
\end_layout

\begin_layout Code
a = readSymbol(a)     # this returns tPtr
\end_layout

\begin_layout Code
sa = Deref(a)         # this reads the structure itself
\end_layout

\begin_layout Code
b = sa.b
\end_layout

\begin_layout Code
#
\end_layout

\begin_layout Code
# Or we can do like that
\end_layout

\begin_layout Code
b = sa.Deref.b
\end_layout

\begin_layout Standard
So we use 
\emph on
Deref(p)
\emph default
 to emulate 
\emph on
*p
\emph default
 operation, 
\emph on
p.Deref.attr
\emph default
 to emulate 
\emph on
p->attr
\emph default
 operation.
\end_layout

\begin_layout Standard
The main reason why this special type is needed is to preserve information
 while reading global pointers to structs using 
\series bold
\emph on
readSymbol
\series default
\emph default
 function (see below).
\end_layout

\begin_layout Subsubsection
SmartString
\end_layout

\begin_layout Standard
This type is used to represent variables and structure fields declared in
 C as 'char *' or 'char []'.
 This is a subclass of the standard Python string, with additional data
 attached and some methods redefines.
 In particular, we store the pointer value and address of the variable.
 For example, if we have in kernel sources a variable declared like that:
\end_layout

\begin_layout Code
char *testvar;
\end_layout

\begin_layout Standard
and the first 7 bytes of it are 
\begin_inset Quotes eld
\end_inset

abc
\backslash
0def
\begin_inset Quotes erd
\end_inset

.
 We'll be able to do the following in Python:
\end_layout

\begin_layout Code
# Read the variable, return SmartString object
\end_layout

\begin_layout Code
s = readSymbol("testvar")
\end_layout

\begin_layout Code
# Print thes string using C NULL-terminated convention (i.e."abc")
\end_layout

\begin_layout Code
print s
\end_layout

\begin_layout Code
# print 2 chars after NULL
\end_layout

\begin_layout Code
print s[4:6]
\end_layout

\begin_layout Code
# Print the address of testvar (i.e.
 &testvar)
\end_layout

\begin_layout Code
print Addr(testvar)
\end_layout

\begin_layout Code
# print the pointer value
\end_layout

\begin_layout Code
print long(testvar)         # works in Python 2.4 and later
\end_layout

\begin_layout Code
print testvar.ptr           # works in Python 2.3 and later
\end_layout

\begin_layout Standard
By default, readSymbol() reads and stores just the first 256 chars.
 If you need to read more, you can use the pointer value (retrieved as shown
 above).
\end_layout

\begin_layout Section
Environment And Command-line Options
\end_layout

\begin_layout Subsection
Loading The Extension
\end_layout

\begin_layout Standard
Extension is a shared library built so that it can be loaded from 
\series bold
\emph on
Crash 
\series default
\emph default
using a built-in 
\emph on
extend
\emph default
 command, e.g.
\end_layout

\begin_layout Code

\family typewriter
crash> extend /path/to/extension/python32.so
\family default
 
\end_layout

\begin_layout Standard
It is not very practical to do this manually every time, so it is recommended
 to put it into your crash startup file.
 The name of this file is derived from the name of your 
\series bold
\emph on
Crash 
\series default
\emph default
executable, so if it is named 
\series bold
\emph on
crash32
\series default
\emph default
, the initialization file will be .crash32rc.
 This is handy if you are using AMD64 host running 64-bits as your dedicated
 dump-analysis machine.
 In this case you need to have two 
\series bold
\emph on
Crash
\series default
\emph default
 executables - one built for 32-bit, another one for 64-bit.
 You will need two copies of extensions too.
 So you can name 
\series bold
\emph on
Crash 
\series default
\emph default
executables 
\series bold
\emph on
crash32
\series default
\emph default
 and 
\series bold
\emph on
crash64
\series default
\emph default
 and they will use initialization files .
\emph on
crash32rc
\emph default
 and .
\emph on
crash64rc.
\end_layout

\begin_layout Standard
The initialization files are first searched in your current directory, then
 in your home directory.
 So if you create in your home directory a file ~/.crashrc32 containing the
 line
\end_layout

\begin_layout Code

\family typewriter
extend /path/to/extension/python32.so
\family default
 
\end_layout

\begin_layout Standard
it will be loaded every time your start 
\series bold
\emph on
Crash
\series default
\emph default
.
 The default directory where extension is installed when doing 'make install'
 is /usr/local/lib.
\end_layout

\begin_layout Subsection
Options
\end_layout

\begin_layout Standard
Options that you pass to your program on the command-line (whether from
 crash environment or shell environment) are parsed when you do 
\end_layout

\begin_layout Code
from pykdump.API import *
\end_layout

\begin_layout Standard
You can pass a number of options that are consumed by API itself; if you
 specify them on the command line they will modify the behavior of framework
 itself but will not be passed to an application.
 Here are these options:
\end_layout

\begin_layout Itemize
--debug=n
\end_layout

\begin_layout Itemize
--ext=0/1
\end_layout

\begin_layout Itemize
--crash=crashcommandpath
\end_layout

\begin_layout Itemize
--vmcore vmcorefile
\end_layout

\begin_layout Itemize
--vmlinux vmlinuxfile
\end_layout

\begin_layout Itemize
--sysmap sysmapfile
\end_layout

\begin_layout Itemize
--nopysco
\end_layout

\begin_layout Itemize
--experimental
\end_layout

\begin_layout Standard
These options are for developers and should not be used in normal programs.
\end_layout

\begin_layout Standard
An example of options preprocessing: if you invoke your program as
\end_layout

\begin_layout Code
crash32> epython mytest.py --debug=1 -d1 arg1 arg2
\end_layout

\begin_layout Standard
the application will see in sys.argv only
\end_layout

\begin_layout Code
-d1 arg1 arg2
\end_layout

\begin_layout Standard
and API will print some internal debugging messages
\end_layout

\begin_layout Subsection
Environment
\end_layout

\begin_layout Itemize
PYKDYMPDEBUG=1 enables debugging messages of C-extension
\end_layout

\begin_layout Itemize
PYTHONPATH can be used in mixed 64 bit environment to specify where 32-bit
 Python libraries are located.
 This is not ready for general usage yet.
\end_layout

\begin_layout Subsection
Starting Python Scripts Outside Crash
\end_layout

\begin_layout Standard
Using Python programs in Crash environment consists of three steps:
\end_layout

\begin_layout Enumerate
Start 
\series bold
\emph on
crash
\series default
\emph default
 specifying the needed dump files and options
\end_layout

\begin_layout Enumerate
Load the 
\series bold
\emph on
pykdump
\series default
\emph default
 extension
\end_layout

\begin_layout Enumerate
Start you program using 
\series bold
\emph on
epython
\series default
\emph default
 command
\end_layout

\begin_layout Standard
For example:
\end_layout

\begin_layout Code
{asid 13:46:46} crash32  /data/Dumps/Fermi/vmlinux-2.4.21-47.ELsmp 
\backslash
          
\end_layout

\begin_layout Code
    /data/Dumps/Fermi/vmcore 
\end_layout

\begin_layout Code
...
\end_layout

\begin_layout Code
crash32> extend /uuu/users/sid/tools/pykdump/Extension/pykdump32.so /uuu/users/si
d/tools/pykdump/Extension/pykdump32.so: shared object loaded 
\end_layout

\begin_layout Code
crash32> epython progs/netdev.py 
\end_layout

\begin_layout Standard
If 'netdev.py' is a highly untrivial program doing automated dump-analysis,
 you may want to run it on several dumps without doing anything else.
 So it would be nice to be able to automate the three steps above (well,
 loading the extension can be automated by doing it in crash initialization
 file).
 The following should work, started from normal shell prompt:
\end_layout

\begin_layout Code
{asid 14:00:27} progs/netdev.py /data/Dumps/Fermi
\end_layout

\begin_layout Standard
This command does the following:
\end_layout

\begin_layout Itemize
searches for needed files in /data/Dumps/Fermi directory (see below for
 how this is done)
\end_layout

\begin_layout Itemize
creates a temporary file putting there commands to run, including loading
 the extension and executing 'epython' with needed arguments
\end_layout

\begin_layout Itemize
starts 
\series bold
\emph on
crash 
\series default
\emph default
passing to it the name of that script file
\end_layout

\begin_layout Subsubsection
Searching For Needed Files
\end_layout

\begin_layout Standard
To pass the dump location on the command line, you specify the base dump
 directory.
 The program will search this directory for files needed to be passed to
 crash as arguments.
 If you do not specify any directory at all, it will try to use the files
 in the current directory.
 If no dump/vmlinux files are available in the current directory, the program
 will try to use the live kernel and /dev/crash (or /dev/mem).
 Here is how files are searched (using * wildcard in usual sense):
\end_layout

\begin_layout Itemize
if there is 'System.map*' file, it will be used (the 1st one if there are
 several of them) 
\end_layout

\begin_layout Itemize
if there is 'vmlinux*' file and it is has a reasonable full name (at this
 moment this means that it does not have .gz, .bz2, .tgz or .debug extension)
 it will be used 
\end_layout

\begin_layout Itemize
if there is 'vmcore*' file and it has a reasonable name, it will be used
\end_layout

\begin_layout Standard
This works in most cases, but still needs improvements
\end_layout

\begin_layout Section
Reference
\end_layout

\begin_layout Standard
You access API by importing pykdump.API in your Python program:
\end_layout

\begin_layout Code
from pykdump.API import *
\end_layout

\begin_layout Standard
Note: if you want your program to be as portable as possible, please put
 this import in the beginning, before importing anything else.
 In some cases (e.g.
 mixed 32/64 bit environment) this import changes the order of directories
 used to locate the needed modules (e.g.
 sys.path)
\end_layout

\begin_layout Code

\end_layout

\begin_layout Subsection
Some Useful Globals
\end_layout

\begin_layout Standard
Immediately after importing pykdump.API you can access some useful variables
 grouped in a 'sys_info' object
\end_layout

\begin_layout Subsubsection*
sys_info
\end_layout

\begin_layout Standard
this is an object with several attributes obtained from 'sys' command.
 For example:
\end_layout

\begin_layout Code
      KERNEL: /Dumps/Linux/test/vmlinux-2.6.9-22.ELsmp
\end_layout

\begin_layout Code
    DUMPFILE: /Dumps/Linux/test/vmcore-netdump-2.6.9-22.ELsmp  [PARTIAL DUMP]
\end_layout

\begin_layout Code
        CPUS: 4
\end_layout

\begin_layout Code
        DATE: Wed Feb  8 10:19:55 2006
\end_layout

\begin_layout Code
      UPTIME: 23:08:52
\end_layout

\begin_layout Code
LOAD AVERAGE: 0.19, 0.07, 0.02
\end_layout

\begin_layout Code
       TASKS: 111
\end_layout

\begin_layout Code
    NODENAME: whittle
\end_layout

\begin_layout Code
     RELEASE: 2.6.9-22.ELsmp
\end_layout

\begin_layout Code
     VERSION: #1 SMP Mon Sep 19 18:32:14 EDT 2005
\end_layout

\begin_layout Code
     MACHINE: i686  (3002 Mhz)
\end_layout

\begin_layout Code
      MEMORY: 8.4 GB
\end_layout

\begin_layout Code
       PANIC: "Oops: 0002 [#1]" (check log for details)
\end_layout

\begin_layout Standard
each string is split into key/value and stored in 'sys_info'.
 The access can be done in two ways:
\end_layout

\begin_layout Itemize
for those keys that do not contain spaces we can use sys_info.CPUS syntax
 to obtain number of CPUs (converted to integer type for convenience) 
\end_layout

\begin_layout Itemize
for any key (both with and without spaces) we can retrieve the value using
 syntax 
\family typewriter
\emph on
sys_info["LOAD AVERAGE"]
\end_layout

\begin_layout Standard
In addition to values obtained from 'sys' command, we put some other useful
 values into 
\emph on
sys_info
\emph default
:
\end_layout

\begin_layout Itemize
HZ - the HZ value 
\end_layout

\begin_layout Itemize
pointersize - this is the size of (void *) in this dump, in bytes 
\end_layout

\begin_layout Itemize
livedump - is true if we are running on a live dump (i.e.
 using /dev/crash on a live machine) 
\end_layout

\begin_layout Itemize
kernel - the stripped version of KERNEL containing just three digits, e.g.
 "2.6.9"
\end_layout

\begin_layout Standard
Examples:
\end_layout

\begin_layout Code
    if (sys_info.kernel >= "2.6.0"):
\end_layout

\begin_layout Code
        sched_clock2ms = sched_clock2ms_26_jiffies
\end_layout

\begin_layout Code
    else:
\end_layout

\begin_layout Code
        sched_clock2ms = sched_clock2ms_24
\end_layout

\begin_layout Code
    for cpu in range(0, sys_info.CPUS):
\end_layout

\begin_layout Code
       ...
\end_layout

\begin_layout Subsection
Sending Commands To GDB And CRASH
\end_layout

\begin_layout Standard
Sometimes it is useful to execute an explicit GDB or CRASH command and obtain
 the result.
 For example, instead of writing your own 'ps' command you want to use built-in
 'ps' command to parse its output and use this data.
 Here are two commands that perform these tasks:
\end_layout

\begin_layout Description
exec_gdb_command - execute a GDB command and return result as string
\end_layout

\begin_layout Code
result = exec_gdb_command(command)
\end_layout

\begin_layout Description
exec_crash_command - execute a CRASH command and return result as string
\end_layout

\begin_layout Code
result = exec_crash_command(command)
\end_layout

\begin_layout Standard
If we use these commands from extension, we do direct calls to internal
 GDB and CRASH functions.
 
\end_layout

\begin_layout Subsection
Functions To Read Data
\end_layout

\begin_layout Description
readSU - read a Struct or Union
\end_layout

\begin_layout Code
obj = readSU(suname, addr) 
\end_layout

\begin_layout Standard

\emph on
suname
\emph default
 is a string specifying struct or union name, addr is an address (integer).
 On success, returns an object (an instance of StructResult) representing
 the read info.
 This object can be used to access separate fields.
 This is similar to crash/GDB 'struct name addr' command.
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout Code

\family typewriter
obj = readSU('struct gendisk', 0x12345678)
\end_layout

\begin_layout Description
readSymbol - read information using a global variable
\end_layout

\begin_layout Code
obj = readSymbol(symname[, art=def])
\end_layout

\begin_layout Standard
We analyze the type of the global variable and return the result accordingly.
 This is similar to crash/GDB 'p symname' command 
\end_layout

\begin_layout Standard
At this moment we don't support all possible types.
 Here is what is supported: 
\end_layout

\begin_layout Itemize
a simple type (e.g.
 int/long), we return result as an integer 
\end_layout

\begin_layout Itemize
a struct/union (in this case we return an object similar to that returned
 by readSU) 
\end_layout

\begin_layout Itemize
an array of simple types - we return a Python list of values 
\end_layout

\begin_layout Itemize
an array of struct/union - we return a Python list of StructResult objects
\end_layout

\begin_layout Itemize
a multidimensional (up to 3 indices) array of basic types or structs/unions
\end_layout

\begin_layout Itemize
a pointer to struct/union
\end_layout

\begin_layout Standard
Examples: 
\end_layout

\begin_layout Code
    tcp_hashinfo = readSymbol('tcp_hashinfo')
\end_layout

\begin_layout Code
    for addr in readSymbol('major_names'):
\end_layout

\begin_layout Code
        print addr
\end_layout

\begin_layout Standard
In some cases we know the definition of the symbol but this information
 is not accessible from the dump.
 This happens, for example, when symbol definition resides in a loadable
 module.
 We still can obtain symbol's address but cannot find its definition.
 In this case you can pass a 2nd argument as a string containing C-statement
 with variable definition ('art' stands for 'artificial').
 Example: 
\end_layout

\begin_layout Code
    # On those kernels where unix sockets are built as a module, we cannot
 find
\end_layout

\begin_layout Code
    # symbolic info for unix_socket_table
\end_layout

\begin_layout Code
    try:
\end_layout

\begin_layout Code
        ust = whatis("unix_socket_table")
\end_layout

\begin_layout Code
        unix_socket_table = readSymbol("unix_socket_table")
\end_layout

\begin_layout Code
    except:
\end_layout

\begin_layout Code
        descr = "struct hlist_head unix_socket_table[257];"
\end_layout

\begin_layout Code
        print "We don't have symbolic access to unix_socket_table, assuming"
\end_layout

\begin_layout Code
        print descr
\end_layout

\begin_layout Code
        unix_socket_table = readSymbol("unix_socket_table", descr)
\end_layout

\begin_layout Description
readSUListFromHead - read a list of struct/union linked by 
\emph on
list_head
\end_layout

\begin_layout Code
slist = readSUListFromHead(headaddr, listfieldname, mystruct,
\end_layout

\begin_layout Code
                               maxel=1000, inchead = False)
\end_layout

\begin_layout Code

\end_layout

\begin_layout Standard
This function can be used to traverse a list of structures linked by embedded
 
\emph on
list_head
\emph default
 member.
 We recommend to read the Linux documentation to better understand how this
 is normally used.
 C-headers define some macros to work with such lists and we tried to emulate
 these macros.
 
\end_layout

\begin_layout Standard
For example, the C-structure definition is:
\end_layout

\begin_layout Code
struct Ex {
\end_layout

\begin_layout Code
    int a;
\end_layout

\begin_layout Code
    list_head next;
\end_layout

\begin_layout Code
};
\end_layout

\begin_layout Code
 
\end_layout

\begin_layout Code
struct Ex head;
\end_layout

\begin_layout Standard
To traverse this list, we need to specify the address of the first struct,
 the name of 'list_head' field and the name of structure itself.
 We can specify the maximum number of elements the function will return
 and whether to return the head itself.
 There are two different ways how 
\emph on
list_head 
\emph default
is used in kernel sources: we can have a separate instance of it (not embedded
 in any other structure), or it can be already embedded.
 In most cases 
\emph on
list_head 
\emph default
is declared standalone like that:
\end_layout

\begin_layout Code
static LIST_HEAD(all_bdevs);
\end_layout

\begin_layout Standard
and we should not return any structure matching the head itself.
\end_layout

\begin_layout Standard
Example: 
\end_layout

\begin_layout Code
u = {}
\end_layout

\begin_layout Code
for s in readSUListFromHead('all_bdevs', 'bd_list', 'struct block_device'):
\end_layout

\begin_layout Code
        u[s.bd_disk] = 1
\end_layout

\begin_layout Code

\end_layout

\begin_layout Standard
And here are some relevant definitions: 
\end_layout

\begin_layout Code
crash64> whatis all_bdevs
\end_layout

\begin_layout Code
struct list_head all_bdevs;
\end_layout

\begin_layout Code
crash64> struct block_device
\end_layout

\begin_layout Code
struct block_device {
\end_layout

\begin_layout Code
    dev_t bd_dev;
\end_layout

\begin_layout Code
    struct inode *bd_inode;
\end_layout

\begin_layout Code
    int bd_openers;
\end_layout

\begin_layout Code
    struct semaphore bd_sem;
\end_layout

\begin_layout Code
    struct semaphore bd_mount_sem;
\end_layout

\begin_layout Code
    struct list_head bd_inodes;
\end_layout

\begin_layout Code
    void *bd_holder;
\end_layout

\begin_layout Code
    int bd_holders;
\end_layout

\begin_layout Code
    struct block_device *bd_contains;
\end_layout

\begin_layout Code
    unsigned int bd_block_size;
\end_layout

\begin_layout Code
    struct hd_struct *bd_part;
\end_layout

\begin_layout Code
    unsigned int bd_part_count;
\end_layout

\begin_layout Code
    int bd_invalidated;
\end_layout

\begin_layout Code
    struct gendisk *bd_disk;                             <=== we want these
 structures
\end_layout

\begin_layout Code
    struct list_head bd_list;                            <=== embedded list_head
 
\end_layout

\begin_layout Code
    struct backing_dev_info *bd_inode_backing_dev_info;
\end_layout

\begin_layout Code
    long unsigned int bd_private;
\end_layout

\begin_layout Code
}
\end_layout

\begin_layout Code
SIZE: 192
\end_layout

\begin_layout Description
readList - traverse a simple linked list
\end_layout

\begin_layout Code
ptrlist = readList(start, offset=0, maxel = 1000, inchead = True) 
\end_layout

\begin_layout Standard
Returns a list of integers (addresses).
 We assume that the list starts at 'start', the next pointer is at 'offset'.
 List traversal stops when the next pointer is NULL, has the same value
 as start or we have reached 'maxel' value (by default, 1000).
 'inchead' parameter specifies whether the result will include 'start' address
 itself or not.
 Some Linux kernel macros (e.g.
 list_for_each_entry) assume that the head list_head structure is standalone
 but the next nodes are embedded in some other structure.
 In cases like that we don't want the address of the head itself to be included.
 
\end_layout

\begin_layout Description
getListSize - follow list pointers and return the number of elements
\end_layout

\begin_layout Code
n = readList(start, offset, maxel)
\end_layout

\begin_layout Standard
Works similar to the previous function, but is implemented in C (so is faster)
 and does not have default values for 
\series bold
offset
\series default
 and 
\series bold
maxel
\series default
.
 It makes sense to use this function if you need just a number of structures
 in the list, not addresses of each structure.
 It is OK to use 
\series bold
readList
\series default
 to get a list of addresses and then use len(ptrlist).
 But if a list is huge (>1,000,000 elements), 
\series bold
getListSize
\series default
 will be 3-10 times faster.
\end_layout

\begin_layout Description
readStructNext - traverse a list of structs connected by 'next' pointer
\end_layout

\begin_layout Code
structlist = readStructNext(head, nextname)
\end_layout

\begin_layout Standard
This function is built on top of 
\series bold
\emph on
readList 
\series default
\emph default
and the 1st paramater can be either a 
\emph on
struct 
\emph default
object or a a pointer to 
\emph on
struct
\emph default
 object.
 For example, we have the following definitions in 
\emph on
C:
\end_layout

\begin_layout Code
struct Example {
\end_layout

\begin_layout Code
    int a;
\end_layout

\begin_layout Code
    struct Example *nptr;
\end_layout

\begin_layout Code
};
\end_layout

\begin_layout Code
struct Example *elist;
\end_layout

\begin_layout Standard
Then in Pykdump we can traverse this list in the following way:
\end_layout

\begin_layout Code
elist = readSymbol("elist)      # This is a pointer to struct
\end_layout

\begin_layout Code
for s in readStructNext(elist, "nptr"):
\end_layout

\begin_layout Code
    print s.a
\end_layout

\begin_layout Description
readPtr - read a pointer from address, i.e.
 an integer of appropriate for this architecture size
\end_layout

\begin_layout Code
newaddr = readPtr(addr) 
\end_layout

\begin_layout Standard
Dereferences a pointer giving a new address.
\end_layout

\begin_layout Description
readU16 - read an unsigned u16 integer
\end_layout

\begin_layout Code
i = readU16(addr)
\end_layout

\begin_layout Description
readU32 - read an unsigned u32 integer
\end_layout

\begin_layout Code
i = readU32(addr)
\end_layout

\begin_layout Description
readmem - read the needed number of bytes from memory
\end_layout

\begin_layout Code
stringvalue = readmem(addr, size, memtype = 'KVADDR')
\end_layout

\begin_layout Standard
Returns a String object (may contain any bytes including NULLs).
 If you use this without C-extension loaded, you can read only 'KVADDR'
 memory (this is what is needed in 99% of all cases).
 If C-extension is loaded, you can specify UVADDR and PHYSADR too
\end_layout

\begin_layout Description
uvtop - convert virtual to physical
\end_layout

\begin_layout Code
physaddr = uvtop(tskaddr, vaddr)
\end_layout

\begin_layout Standard
where 
\series bold
tskaddr 
\series default
is an integer holding process's 'struct task_addr' address and 
\series bold
vaddr 
\series default
is a virtual memory address (such as seen by this process)
\end_layout

\begin_layout Description
readProcessMem - read a given number of bytes from process's userspace memory
\end_layout

\begin_layout Code
mem = readProcessMem(taskaddr, uvaddr, bytes)
\end_layout

\begin_layout Standard
where 
\series bold
tskaddr
\series default
 is an integer holding process's 'struct task_addr' address and 
\series bold
uvaddr
\series default
 is a virtual memory address (such as seen by this process)
\end_layout

\begin_layout Subsection
Functions For Symbolic Info Access
\end_layout

\begin_layout Description
symbol_exists - check whether the global symbol exists
\end_layout

\begin_layout Code
boolval = symbol_exists(symbol) 
\end_layout

\begin_layout Standard
returns True/False (or 0/1) depending on whether this symbol is present
 in the kernel/dump symbol table 
\end_layout

\begin_layout Description
sym2addr - return the address of symbol
\end_layout

\begin_layout Code
addr = sym2addr(symbol) 
\end_layout

\begin_layout Standard
Returns the address matching this symbol.
 
\end_layout

\begin_layout Description
addr2sym - return the symbol name matching this addr
\end_layout

\begin_layout Code
strval = addr2sym(addr) 
\end_layout

\begin_layout Standard
Return the symbolic name matching this addr 
\end_layout

\begin_layout Description
getSizeOf - return the size of type or symbol
\end_layout

\begin_layout Code
size = getSizeOf(strval) 
\end_layout

\begin_layout Standard
Emulates "C" macro sizeof(strval).
 That is, it can be used both for types and global variables, e.g.
 
\end_layout

\begin_layout Code
    sint = getSizeOf("unsigned long int")
\end_layout

\begin_layout Code
    ssock = getSizeOf("struct sock")
\end_layout

\begin_layout Code
    sizetable = getSizeOF("tcp_hashinfo")
\end_layout

\begin_layout Description
struct_size - return the size of the struct or union
\end_layout

\begin_layout Code
size = struct_size(sname) 
\end_layout

\begin_layout Standard
This returns the size of struct or union based on its symbolic name.
 It is somewhat similar to getSizeOf(sname) but will work for struct/union
 only.
 If this is not a struct/union or if this struct/union does not exists,
 the function returns -1 
\end_layout

\begin_layout Description
member_size - return the size of struct/union member
\end_layout

\begin_layout Code
size = member_size(sname, mname) 
\end_layout

\begin_layout Standard
Returns the size of struct/union member (if it exists), -1 otherwise.
 sname is a string with struct name, mname is a string with member name
 
\end_layout

\begin_layout Description
member_offset - return the offset of struct/union member
\end_layout

\begin_layout Code
offset - member_offset(sname, mname) 
\end_layout

\begin_layout Standard
Returns offset relative to struct/union 
\end_layout

\begin_layout Description
getTypedefInfo - convert ''typedef'' to real type
\end_layout

\begin_layout Code
strval = getTypedefInfo(ptype) 
\end_layout

\begin_layout Standard
Can be used to find the real type of typedefs.
 E.g.
 for "__u32" we'll get "unsigned int".
 If the type does not exits, returns None 
\end_layout

\begin_layout Subsubsection
Working with struct/union representation
\end_layout

\begin_layout Standard
In some cases you need to compute offsets manually or check whether a certain
 field exists at all.
 If we cannot use the simple functions described above (e.g.
 'member_offset') we can retrieve the full structure definition and access
 information for individual fields.
\end_layout

\begin_layout Code
info = getStructInfo(sname) 
\end_layout

\begin_layout Standard
Here an argument is a string with structure/union name (including 'struct/union'
 specifier) and result is an object that can be used for retrieving further
 details.
 Obtaining struct info is computationally expensive (at this moment we parse
 the text output of 'ptype' command).
 To improve the performance, we cache results using structure name as a
 key.
 So it's OK to call this function many times for the same type - the first
 time the real parsing will be done and next invocations will reuse the
 already available information.
 You can use the obtained 'info' object to find many different things, for
 example 
\end_layout

\begin_layout Itemize
info.size returns the size of this structure
\end_layout

\begin_layout Itemize
info.stype returns the type definition (e.g.
 'struct sock') 
\end_layout

\begin_layout Standard
To obtain info about a specific field: 
\end_layout

\begin_layout Code
fieldinfo = info[fieldname] 
\end_layout

\begin_layout Standard
here the returned object will describe field-specific information.
 Example: 
\end_layout

\begin_layout Code
    rtable_i = getStructInfo("struct rtable")
\end_layout

\begin_layout Code
    rt_next_off = rtable_i["u"].offset
\end_layout

\begin_layout Code
    rt_next_size = rtable_i["u"].size
\end_layout

\begin_layout Standard
Here we find the offset and size of field 'u' in 'struct rtable'.
 Once again, in many cases we can do the same using simplified functions
 (like 'member_offset/member_size').
 
\end_layout

\begin_layout Standard
Using getStructInfo is mainly of interest for API developers, not end-users.
 But there are some cases where there is no simplified API (yet).
 For example, the structure definition may include several levels of 'internal'
 struct definitions.
 
\end_layout

\begin_layout Code
struct AAA {
\end_layout

\begin_layout Code
  struct {
\end_layout

\begin_layout Code
    int a;
\end_layout

\begin_layout Code
    struct {
\end_layout

\begin_layout Code
       void *a;
\end_layout

\begin_layout Code
    } s2;
\end_layout

\begin_layout Code
  } s1;
\end_layout

\begin_layout Code
} t;
\end_layout

\begin_layout Standard
In this case it is rather difficult to obtain info about 't.s1.s2.a'.
 As a matter of fact, in some cases crash does not report offsets of nested
 structs while using 'struct -o ...' command.
 
\end_layout

\begin_layout Standard
Another case where we need to use StructInfo objects in programs is the
 case when structure/union definition is missing in vmlinux/vmcore.
 There are even some cases when it is there but crash is not able to retrieve
 it! In such cases we can create 'artificial' StructInfo objects.
 Here is a practical example how to create 'struct sock_inet' when its definitio
n is missing: 
\end_layout

\begin_layout Code
    # Let us create inet_sock if needed
\end_layout

\begin_layout Code
    if (struct_size("struct inet_sock") == -1):
\end_layout

\begin_layout Code
        as = ArtStructInfo("struct inet_sock")
\end_layout

\begin_layout Code
        as.append("struct sock    sk;")
\end_layout

\begin_layout Code
        if (symbol_exists("tcpv6_protocol") and
\end_layout

\begin_layout Code
            symbol_exists("udpv6_protocol")):
\end_layout

\begin_layout Code
            print "Adding struct ipv6_pinfo *pinet6;"
\end_layout

\begin_layout Code
            as.append("struct ipv6_pinfo *pinet6;")
\end_layout

\begin_layout Code
        iopti = getStructInfo("struct inet_opt")
\end_layout

\begin_layout Code
        as.append(iopti)
\end_layout

\begin_layout Code
        # print as
\end_layout

\begin_layout Code
        # tcp_sock is inet_sock followed by tcp_opt
\end_layout

\begin_layout Code
        tas = ArtStructInfo("struct tcp_sock")
\end_layout

\begin_layout Code
        tas.append(as)
\end_layout

\begin_layout Code
        tas.append("struct tcp_opt tcp;")
\end_layout

\begin_layout Standard
We start from creating an empty 'artificial' StructInfo object specifying
 its name.
 After that we need to fill-in the info.
 We can do this in two ways: 
\end_layout

\begin_layout Itemize
copying info from already existing definitions, retrieved from the dump/vmlinux
 
\end_layout

\begin_layout Itemize
add definitions using syntax similar to "C".
 
\end_layout

\begin_layout Standard
In the example above we start from adding "struct sock sk;" as the first
 field.
 After that we conditionally add "struct ipv6_pinfo *pinet6;".
 Finally, we obtain info about "struct inet_opt" using getStructInfo() and
 append it.
 
\end_layout

\begin_layout Standard
The created 'as' object is added to StructInfo cache so that it can be used
 by other functions just as a real structinfo.
 In particular, after constructing "struct inet_sock" we are using it to
 construct "struct tcp_sock".
 
\end_layout

\begin_layout Standard
Artificial unions can be constructed in a similar way using ArtUnionInfo.
 The main difference between ArtStructInfo and ArtUnionInfo objects is that
 for structs when we append new fields, their offset is increasing according
 to type size; for unions all offsets are just zero.
 
\end_layout

\begin_layout Subsubsection
Loading Extra Debugging Modules
\end_layout

\begin_layout Standard
Sometimes we need symbolic information that is present only in DLKMs.
 For example, we want to print private information for 
\emph on
tg3
\emph default
 driver.
 In this case the debugging version of this module need to be present either
 in distribution-specific standard location, or in the dump directory.
 Then you can load that info by using 
\series bold
loadModule
\series default
 function:
\end_layout

\begin_layout Code
rc = loadModule(modname, ofile = None)
\end_layout

\begin_layout Standard
The first argument is a module name (as listed by 
\emph on
lsmod
\emph default
).
 If the second argument is not specified, the object file will be searched
 in standard locations.
 Or you can specify the exact filename (with path) using the second argument.
 Examples
\end_layout

\begin_layout Code
rc = loadModule("tg3")
\end_layout

\begin_layout Code
rc = loadModule("e1000", "/debugmods/e1000.ko")
\end_layout

\begin_layout Standard
In both cases the return value will be 
\emph on
True
\emph default
 (of loading succeeded) or 
\emph on
False
\emph default
 (if it failed)
\end_layout

\begin_layout Subsubsection
Error Processing
\end_layout

\begin_layout Standard
In most cases we use the standard Python exceptions to report errors.
 For example, if you try to read a struct with a type that is not available,
 
\emph on
TypeError
\emph default
 is raised.
 When an error occurs in C-extension module, e.g.
 we cannot read the specified memory address, 
\emph on
crashError
\emph default
 exception is raised.
\end_layout

\begin_layout Subsection
Conversions And Bit Manipulation
\end_layout

\begin_layout Standard
Python does not have a concept of unsigned integers and integer size.
 Traditionally, there were two integer types - normal integers and long
 integers.
 The difference was that normal integers were fitting into platform-specific
 native 'long int' type, and long integers were arbitrary-precision.
 The two flavors of integer constants are differentiated by 'L' suffix:
\end_layout

\begin_layout Code
>>> type (1L) <type 'long'> 
\end_layout

\begin_layout Code
>>> type (1) <type 'int'> 
\end_layout

\begin_layout Standard
In some cases kernel C-code relies on size or signed/unsigned specific behaviour.
 This creates problems when we try to emulate C-code in Python, for example:
\end_layout

\begin_layout Code
>>> print hex(~1)
\end_layout

\begin_layout Code
-0x2 
\end_layout

\begin_layout Standard
Is not quite what we expect.
 You should be very attentive while porting to Python snippets of C-code
 dealing with bitwise operations.
\end_layout

\begin_layout Description
sLong - convert bits from a long number to 'signed long'
\end_layout

\begin_layout Code
i = 0xffffffff
\end_layout

\begin_layout Code
print i, sLong(i)
\end_layout

\begin_layout Code
4294967295 -1 
\end_layout

\begin_layout Description
FD_ISSET - emulate C macro
\end_layout

\begin_layout Code
FD_ISSET(fd, set)
\end_layout

\begin_layout Standard
emulates C-macro 
\end_layout

\begin_layout Code
int FD_ISSET(int fd, fd_set *set);
\end_layout

\end_body
\end_document
